#!/bin/bash
set -eu

# Setup env

# For the build step concourse will set the following environment variables:
# SOURCE_PATH - path to component repository root directory.
# BINARY_PATH - path to an existing (empty) directory to place build results into.

if [[ $(uname) == 'Darwin' ]]; then
  READLINK_BIN="greadlink"
else
  READLINK_BIN="readlink"
fi

if [[ -z "${SOURCE_PATH:-}" ]]; then
  export SOURCE_PATH="$(${READLINK_BIN} -f $(dirname ${0})/..)"
else
  export SOURCE_PATH="$(${READLINK_BIN} -f "${SOURCE_PATH}")"
fi

if [[ -z "${BINARY_PATH:-}" ]]; then
  export BINARY_PATH="${SOURCE_PATH}/bin"
else
  export BINARY_PATH="$(${READLINK_BIN} -f "${BINARY_PATH}")/bin"
fi

if [[ -z "${GARDENER_WEBSITE_GENERATOR_PATH:-}" ]]; then
  generatorRepoPath="$(${READLINK_BIN} -f $(dirname ${0})/..)"
else
  generatorRepoPath="$(${READLINK_BIN} -f "${GARDENER_WEBSITE_GENERATOR_PATH}")"
fi
if [[ ! -d "${generatorRepoPath}" ]]; then
  echo "website-generator directory path is invalid ["${generatorRepoPath}"]. Set $GARDENER_WEBSITE_GENERATOR_PATH to a correct path or run from website-generator cloned repo."
  exit 1
fi
if [[ -z "${GARDENER_WEBSITE_PATH:-}" ]]; then
  # Fallback to "website" repo cloned as peer directory to "website-generator"
  websiteRepoPath="$(${READLINK_BIN} -f $(dirname ${0})/../../website)"
else
  websiteRepoPath="$(${READLINK_BIN} -f "${GARDENER_WEBSITE_PATH}")"
fi

generator=${generatorRepoPath}
website=${websiteRepoPath}/docs
echo "Generated site directory: ${website}"

HUGO_CONTENT=${HUGO_CONTENT:-$SOURCE_PATH/hugo/content}
# Note that currently docforge supports only paths relative to the hugo directory for data 
HUGO_DATA=${HUGO_DATA:-$SOURCE_PATH/hugo/data}
WWW=${WWW:-$SOURCE_PATH/hugo/public}
BOM_FILE=${BOM_FILE:-$SOURCE_PATH/component_descriptor.cnudie.yaml}
LSS_VERSION_JSON_PATH=${LSS_VERSION_JSON_PATH:-$HUGO_DATA/version.json}
COMPONENTS_INDEX_PATH=${COMPONENTS_INDEX_PATH:-$SOURCE_PATH/components.json}
MANIFEST_PATH=${MANIFEST_PATH:-$BINARY_PATH/rel/manifest.yaml}

getGitHubToken(){
  # Check if gardener-ci is available (in local setup)
  command -v gardener-ci >/dev/null && gardenci="true" || gardenci=""
  if [[ $gardenci == "true" ]]; then
    # Get a (round-robin) random technical GitHub user credentials
    technicalUser=$(gardener-ci config model_element --cfg-type github --cfg-name "${1}" --key credentials | sed -e "s/^GithubCredentials //" -e "s/'/\"/g")
    if [[ -n "${technicalUser}" ]]; then
      # get auth token and strip lead/trail quotes
      echo $(sed -e 's/"//g' <<<$(jq -n '$c.authToken' --argjson c "$technicalUser"))
    fi
  fi
}

GITHUB_OAUTH_TOKEN=${GITHUB_OAUTH_TOKEN:-$(getGitHubToken github_com)}

# Generate components index file

# If this build is upon dependency version upgrade, find out the updated dependency names and versions.
# Must be ones starting with the reserved "dep-upgrade-" prefix located in the $SOURCE_PATH.
joinByChar() {
  local IFS="$1"
  shift
  echo "$*"
}

dependencies=()
dependenciesLocalNames=()
files=$(find . -type f -name "dep-upgrade-*" -exec echo {} +)
for f in $files; do 
    DEP_NAME=${f##*dep-upgrade-}
    dependenciesLocalNames+=( $(echo $DEP_NAME) );
    DEP_VERSION=$(cat $f)
    DEP="$(echo $DEP_NAME)=$(echo $DEP_VERSION)"
    dependencies+=( $(echo $DEP) );
done
compVersionRewriteArg=$(joinByChar , ${dependencies[*]})
if [[ -n "${compVersionRewriteArg}" ]]; then
    DEP_VERSIONS="--comp-version-rewrite=${compVersionRewriteArg}"
fi
if [[ ! -e "${BOM_FILE}" ]]; then
  echo "no $BOM_FILE file found."
  exit 1
# Generate components index and landscape version from a local landscape-setup component desriptor $BOM_FILE, comprising only documentation components
$SOURCE_PATH/scripts/gen.py components -i $BOM_FILE -o $COMPONENTS_INDEX_PATH --validate=true --version-file=$LSS_VERSION_JSON_PATH ${DEP_VERSIONS:-}

if [[ ! -e "${COMPONENTS_INDEX_PATH}" ]]; then
  echo "no $COMPONENTS_INDEX_PATH file found."
  exit 1
fi

cp "${COMPONENTS_INDEX_PATH}" "${SOURCE_PATH}"/hugo/static
cp "${COMPONENTS_INDEX_PATH}" "${HUGO_DATA}"

if [[ ! -e "${LSS_VERSION_JSON_PATH}" ]]; then
  echo "[warning] no $LSS_VERSION_JSON_PATH file found."
  # exit 1
fi

manifestComponentsArg=$(joinByChar , ${dependenciesLocalNames[*]})
if [[ -n "${manifestComponentsArg}" ]]; then
    MANIFEST_COMPS="--include-components=${manifestComponentsArg}"
fi
# Generate the docforge manifest template from landscape BoM
$SOURCE_PATH/scripts/gen.py manifest -i $COMPONENTS_INDEX_PATH -o $MANIFEST_PATH ${MANIFEST_COMPS:-}
if [[ ! -e "${MANIFEST_PATH}" ]]; then
  echo "no $MANIFEST_PATH file found."
  exit 1
fi


# Forge a documentation bundle

docforge -f $MANIFEST_PATH -d $HUGO_CONTENT --hugo --hugo-section-files="readme.md,readme,read.me,index" --github-oauth-token-map="github.com=$GITHUB_OAUTH_TOKEN" --github-info-destination ../data || true

# Run post-forge hugo data pieces
$SOURCE_PATH/scripts/genHugoData.py -i ${COMPONENTS_INDEX_PATH} -hd $HUGO_DATA -hc $HUGO_CONTENT


# Build the website

cd $SOURCE_PATH/hugo && hugo --minify && cd -


echo gardener.cloud >${website}/CNAME

if [[ ${AUTO_PUBLISH:-true} != 'false' ]]; then
  cd ${websiteRepoPath}
  echo
  echo "Committing website changes"
  git add . -A
  git commit -m 'Automatic build triggered by last commit'
fi
